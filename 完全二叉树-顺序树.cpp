
/*

#include<iostream>
//#include<cmath>
using namespace std;//部分时候会冲突
#define maxsize 100 // 定义maxsize的值

// 将data数组定义在main函数外部，使其成为全局变量



/*
总思路
放根节点
依据根节点放子节点进行延伸
    具体过程：找到子节点依据子节点找到父亲，然后利用编号关系放进对应的数组索引位置里面就欧克了
然后增加啊，删除啊，访问啊，修改啊
都是通过遍历数组+覆盖赋值就行了，


链表数同理，放根节点，然后指针指向下一个

*/


/*


char dat[maxsize];//全局数组编译器自动初始化为零数组。
int flag; // 标记左大儿和右大儿

static int find(char x)//传入值X,返回x对应的他爸的索引i
{
    for (int i = 1; i < maxsize; ++i)//不一定所有的值都会进入循环，所以啊
    {
        if (dat[i/2] == x)
        {
            return i;
        }
        //else
        //{11111
            //return -1;//同时考虑没满足的情况，考虑周全一点，不然就不会返回也就是报错了//如果第一次循环没有满足条件，直接就返回了不会进行下一次的循环。所以不能放在这
        //}//如无必要，勿增实体，虽然看着逻辑对称，但是没有用，反而导致错误，看漏大括号的分界范围
        //return -1;//放错地方了，还是放在循环里面
    }
    return -1;
}
//全局函数：所有文件通用
//局部函数：区域内通用
//静态函数：1,方便调用，直接用类的名字就可以实现调用而不用创建额外的对象，2.在一个源文件内的全局，对于其他文件相当于局部函数，实现区域内的全局函数，同时满足避免函数名冲突和也可以在局部文件内部的使用方便不繁琐

//优点：极度严谨（为了满足多面发展，所以严谨暂时缓一缓，维持就好，发展细致与细心是目前学习子任务），但是会被当做是背答案，不好，社会形象倾向于书呆子。面试小心，交流小心，但是学习的时候非常有用，优点之一：严谨，但也要细致，细致 + 严谨才能发挥各自的最大功力，也就是科学学习的最佳效果。

*/
/*
int main() 
{
    // 循环应该从0开始，到maxsize - 1结束
    for (int i = 1; i < maxsize; ++i) 
    {
        dat[i] = '\0'; // 赋值单个空格字符//用空格字符方便索引，不过也可以？
    }
    int n;
    cin >> n;//放即将存入的节点数量


    //放根节点：
    char rootx;
    cin >> rootx;//放数据(根节点例外，因为没有上级节点所以不用这么搞
    int size = 0;//存放根节点
    size++;//放一个进来，先把尺寸加一
    dat[size] = rootx;//根节点在1的位置，刚好把size和索引联系在一起。妙啊MIAOA
    //i = 1放了根节点，接着就是从i=2，放n-1个节点进去了


    //放子节点，因为除了根节点，任何节点都是其他节点的子节点，这个分类是依据关系进行的分类，也可以直接进行粗暴分类，一个一个塞进去，但是仅限于完全的满二叉树、
    int x;//节点的值
    int fx;//节点的父亲节点编号

    bool flag;//标记是大哥还是小弟。//0为大哥，1为小弟
    cin >> x >> flag;


    fx = find(x);//可以直接输入，但是能让操作端渐变就尽最大可能简化用户输入，比如现实中的一个无需验证码直接注册+登录就让一大批人直接用手机号登录，还附带实名认证功能，真TM是个天才。


    for (int i = 2; i <= n - 1; ++i)//分开来了，虽然不知道为何分开放。
    {
        if (fx == -1)
        {
            cout << "x不具有父节点" << endl;
        }
        else
        {
            if (flag == 0)//大哥，左大儿
            {
                dat[2 * i] = x;
            }
            else//小弟，右大儿
            {
                dat[2 * i + 1] = x;
            }
        }
    }
    //void init(x,flag){}传入该节点的值和儿子顺位就好了，可以作为一个函数，半优化，懒，你这就是懒，还半优化算了，别聊了，你这分身乏力啊，赶紧看视频去。


    return 0;
}




//你以为高处不胜寒就是NB？不，高低兼容才是真NB，不胜寒的结果就是被群众抛弃，任何的发展必须是总体的，而不是局部的，不然一定会被打破。you know?









/*
flowus低配代码版？
	这个tab有点太大了hhh


	课前思考：部分
如何构建：1，完全二叉树：
精细地思考而不是把思考当做玩具，失去严肃性的行动必然面临解构与失败。
性质契合：也是简单的一种用顺序表，是编号之后一个一个放进数组里面，给每一个节点加唯一的连续索引，契合了数组的每一个连续索引对应一个值
把自己的输出当做表达，用一种形式主义提升严肃性，而后把无用的形式主义扬弃，无用地占用系统内存的进程越少越好。
挫折的耐受度已经高于标准了，这是一种非常巨大的心里优势，加上思维优势，加上行动，一定可以成功！过程也不是放弃思维的发展，行动为主，占七分，思维二分，情绪一分。我必成功。I Will Be Bound To Success With Praxis/Pratice.
PS：数组存放的数据类型必须是同一种数据类型，链表也难实现，不过倒也可以。

不要觉得某种知识，某种客观实在只要过不了你自己这关的就是不行的，你没有资格作为一个现实的质检员，或者说，现实不是围着你转的，你不一定理解现实的种种，但是你可以学习，依据先人的某种方法，或科学，或者其他什么东西去作为一种工具辅助你的理解。接受自己完全的失败，我绝对不可能是全知全能的，所以赶快摒弃一种庸俗的前反思的唯我论，这是高中失败的根源，至于这个的原因是什么呢，到时候再说




知识部分：

二叉树的存储结构：顺序表示法：
基本逻辑：节点的表示就是依靠完全二叉树每个节点的顺序位置，关系就用性质5进行判断，理论必将服务于实践？不，理论本身就是实践过程的母亲，来将行动从理论当中生发出来（类似于一种分娩机能。））
缺点：只适用于严格的满二叉树，对于有空缺的非满二叉树，因为数组的连续存储性质会导致浪费内存（就是内存的连续性硬性要求导致资源浪费）
改进:很明显了，就是因为连续存储导致的问题，那有没有一种方法，可以不利用连续存储而保证类似于数组的性能表现呢？
用处：满二叉树使用。适用范围窄，但是简单。







of course,linklist.

二叉树的存储结构2：链表表示法。
基本逻辑同上，每一个节点放在一个链表的节点中（刚好契合），同时，利用指针进行相互构建
数据结构的构建:一般是默认从0到1，是初始化函数，从1到n是添加函数，从N-》1是减少函数，查找啊访问啊哪些就是一个遍历然后条件处理就好，数据结构的形式，最开始都是从0开始的，不要幻想怎么样可以做一个节点数目为多少的链表？不可能，我们要从0开始构建而不会没有基础直接构建一个空中楼阁，楼房是从0到n构建的而不是一上来思考如何生出来一个4层楼房
应用特点与适用范围：灵活














*/

